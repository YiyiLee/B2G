From b563d58a19e3f1b63e13d6dd62c3bbe8c6416ca4 Mon Sep 17 00:00:00 2001
From: Andreas Pehrson <pehrson@comoyo.com>
Date: Fri, 6 Jun 2014 10:09:17 +0200
Subject: [PATCH] Load gralloc hardware module once in singleton instead of on
 every request

---
 libs/gralloc/gralloc_module.cpp | 38 ++++++++++++++++++++++++--------------
 1 file changed, 24 insertions(+), 14 deletions(-)

diff --git a/libs/gralloc/gralloc_module.cpp b/libs/gralloc/gralloc_module.cpp
index f0afa64..7f21a60 100644
--- a/libs/gralloc/gralloc_module.cpp
+++ b/libs/gralloc/gralloc_module.cpp
@@ -44,11 +44,30 @@ static int s_ump_is_open = 0;
 #include <sys/mman.h>
 #endif
 
+static private_module_t *s_gralloc_module = NULL;
 static pthread_mutex_t s_map_lock = PTHREAD_MUTEX_INITIALIZER;
 
 extern int open_ion_device(private_module_t* m);
 extern void close_ion_device(private_module_t* m);
 
+static int get_gralloc_hw_module(const private_module_t **p_pmodule)
+{
+	if (NULL == s_gralloc_module)
+	{
+		hw_module_t *pmodule = NULL;
+		int ret = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&pmodule);
+		if (ret != 0)
+		{
+			*p_pmodule = NULL;
+			return -ret;
+		}
+		s_gralloc_module = reinterpret_cast<private_module_t *>(pmodule);
+	}
+
+	*p_pmodule = s_gralloc_module;
+	return 0;
+}
+
 static int gralloc_device_open(const hw_module_t* module, const char* name, hw_device_t** device)
 {
 	int status = -EINVAL;
@@ -175,17 +194,13 @@ static int gralloc_register_buffer(gralloc_module_t const *module, buffer_handle
 		int ret;
 		unsigned char *mappedAddress;
 		size_t size = hnd->size;
-		hw_module_t *pmodule = NULL;
 		private_module_t *m = NULL;
 
-		if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&pmodule) == 0)
-		{
-			m = reinterpret_cast<private_module_t *>(pmodule);
-		}
-		else
+		ret = get_gralloc_hw_module((const private_module_t **)&m);
+		if (ret != 0)
 		{
 			AERR("Could not get gralloc module for handle: 0x%x", (unsigned int)hnd);
-			retval = -errno;
+			retval = ret;
 			goto cleanup;
 		}
 
@@ -337,12 +352,10 @@ static int gralloc_lock(gralloc_module_t const *module, buffer_handle_t handle,
 	{
 		*vaddr = (void *)hnd->base;
 #if GRALLOC_ARM_DMA_BUF_MODULE
-		hw_module_t *pmodule = NULL;
 		private_module_t *m = NULL;
 
-		if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&pmodule) == 0)
+		if (get_gralloc_hw_module((const private_module_t **)&m) == 0)
 		{
-			m = reinterpret_cast<private_module_t *>(pmodule);
 			ion_invalidate_fd(m->ion_client, hnd->share_fd);
 		}
 		else
@@ -429,19 +442,16 @@ static int gralloc_unlock(gralloc_module_t const* module, buffer_handle_t handle
 	} else if ( hnd->flags & private_handle_t::PRIV_FLAGS_USES_ION && hnd->writeOwner)
 	{
 #if GRALLOC_ARM_DMA_BUF_MODULE
-		hw_module_t *pmodule = NULL;
 		private_module_t *m = NULL;
 
-		if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, (const hw_module_t **)&pmodule) == 0)
+		if (get_gralloc_hw_module((const private_module_t **)&m) == 0)
 		{
-			m = reinterpret_cast<private_module_t *>(pmodule);
 			ion_sync_fd(m->ion_client, hnd->share_fd);
 		}
 		else
 		{
 			AERR("Unlock couldnot get gralloc module for handle 0x%x\n", (unsigned int)handle);
 		}
-
 #endif
 	}
 
-- 
1.9.0

